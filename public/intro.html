<!DOCTYPE HTML><html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link rel="stylesheet" href="/tachyons.css" /><link rel="stylesheet" href="/pylon.css" /><link rel="stylesheet" href="/nord.css" /><link rel="stylesheet" href="/app.css" /><title>Joy Framework</title></head><body class="bg-purple"><vstack class="mw8 center pa4-ns pa3"><hstack spacing="l"><div class="white"><a href="/" class="white no-underline">ðŸ˜‡Joy</a></div><spacer></spacer><a href="/posts" class="white">Posts</a><a href="https://github.com/joy-framework/joy" class="white">Github</a></hstack><div class="white bg-transparent lh-copy mt4"><h1 id="what-is-joy-">What is joy?</h1>
<p>Like most web frameworks, joy consists of four things:</p>
<ol>
<li>Functions</li>
<li>Routes</li>
<li>Middleware</li>
<li>Handlers (a combo of routes, middleware and functions, also known as controller methods or actions)</li>
</ol>
<p>Unlike most web frameworks, these four things are not opaque and entirely up to you on how you structure them</p>
<h2 id="functions">Functions</h2>
<pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">use</span></span> joy)

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> hello [request]
  (<span class="hljs-name">render</span> <span class="hljs-symbol">:text</span> (<span class="hljs-name">string</span> <span class="hljs-string">"hello "</span> (<span class="hljs-name"><span class="hljs-builtin-name">get-in</span></span> request [<span class="hljs-symbol">:params</span> <span class="hljs-symbol">:name</span>]))))
</code></pre>
<p>This is a just a janet function, it takes a request dictionary and returns a response dictionary, the <code>(render)</code> function is just sugar for <code>{:status 200 :body &quot;hello!&quot;}</code> which is the janet dictionary literal.</p>
<h2 id="routes">Routes</h2>
<pre><code class="lang-clojure">(<span class="hljs-name">defroutes</span> hello-routes
  [<span class="hljs-symbol">:get</span> <span class="hljs-string">"/"</span> home]
  [<span class="hljs-symbol">:post</span> <span class="hljs-string">"/"</span> sweet-home]
  [<span class="hljs-symbol">:get</span> <span class="hljs-string">"/hello/:name"</span> hello])
</code></pre>
<p>Those are routes, they take any number of tuples in the form of</p>
<p><code>[:http-verb &quot;/route/string&quot; name-of-handler-function :optional-alias-of-function]</code></p>
<h2 id="middleware">Middleware</h2>
<p>Next we have middleware, joy has several middleware for working with web applications, but you can make your own and swap or drop all of the built in middleware if you want.</p>
<pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> hello-handler (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;</span></span> (<span class="hljs-name">handler</span> hello-routes)
                       (<span class="hljs-name">logger</span>)))
</code></pre>
<p>Here&#39;s an example using the built in logger, the <code>handler</code> function takes an array of routes and returns a handler wrapped in the middleware functions that call it.</p>
<p>Here&#39;s how a logger middleware function could look</p>
<pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> logger [handler]
  (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [request]
    (<span class="hljs-name"><span class="hljs-builtin-name">printf</span></span> <span class="hljs-string">"q"</span> request)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [response (<span class="hljs-name">handler</span> request)]
      (<span class="hljs-name"><span class="hljs-builtin-name">printf</span></span> <span class="hljs-string">"q"</span> response)
      response)))
</code></pre>
<p>A middleware function takes a handler (which is a function that takes routes and returns a function that takes a request), and then calls that handler on the request in the function it returns!</p>
<p>It&#39;s turtles all the way down.</p>
<h2 id="middleware-explained">Middleware Explained</h2>
<p>The simplicity of this model is really nice but there are a few downsides:</p>
<ol>
<li>Middleware gets called &quot;backwards&quot;</li>
<li>There is a way to stop a middleware stack from being called, but you&#39;d have to resolve the route at the &quot;bottom&quot; of the stack</li>
</ol>
<p>Since the logger middleware gets called &quot;around&quot; the handler function that was passed in, it effectively gets called first, even though
it looks like it gets called last thanks to the thread first macro <code>-&gt;</code>.</p>
<p>The other problem where you can&#39;t stop middleware execution and return something else (like a 500 response) is also problematic when it comes to trying to give different routes different middleware like auth or admin middleware or even api middleware when you have an api along with your traditional html returning web app.</p>
<p>Joy makes these trade offs for the simplicity and gets around problem 2 by offering a &quot;skip&quot; middleware, which essentially can be put on the bottom (or called last) in the web middleware stack and calls the routes first and merges &quot;has this route matched key&quot; to the request which other middleware can inspect and decide to skip processing to speed up large, middleware heavy apps.</p>
<p>In practice though, you typically only have a few middleware stacks Like</p>
<ul>
<li>auth</li>
<li>admin routes</li>
<li>the default joy web stack</li>
<li>and maybe an api stack (without all the cookie/session/csrf/html rendering stuff)</li>
</ul>
<p>so in the worst case (an admin route), you&#39;d be calling four middleware stacks which could be about 20 functions total, not the end of the world, considering how many functions typically get called in a web framework.</p>
<h2 id="server-handlers">Server &amp; Handlers</h2>
<p>The last part of this is wiring up the middleware and handlers with the actual http server, which works like this:</p>
<pre><code class="lang-clojure">(<span class="hljs-name">server</span> hello-handler <span class="hljs-number">8000</span>)
</code></pre>
<p>Which starts up the loop and listens on port 8000 for incoming http requests on <code>http://localhost:8000</code></p>
<p>In the case of multiple handlers, you can combine them before calling <code>server</code> with this handy function</p>
<pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> app (<span class="hljs-name">handlers</span> hello-handler some-other-handler a-third-handler))
</code></pre>
<p>This calls the handlers from left to right, when a route doesn&#39;t match a given set of routes for that handler, it returns nil
and the next handler (function + middleware) is called.</p>
<p>From here we would put that in <code>server</code></p>
<pre><code class="lang-clojure">(<span class="hljs-name">server</span> app <span class="hljs-number">8000</span>)
</code></pre>
<p>And that&#39;s pretty much all there is to joy. There are a lot more middleware and helper functions for common web app stuff like redirects, form submission, static files (mostly for dev, since nginx handles that much better in prod), json responses, sessions, and anti-csrf, but they all play by the same rules, there is nothing special about joy&#39;s middleware and middleware you write, it&#39;s all functions, all the time.</p>
</div></vstack><script src="/app.js"></script></body></html>